{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FHIR Info Gateway","text":"<p>The Info Gateway is a reverse proxy which controls client access to FHIR resources on a server. It works by inspecting FHIR requests and verifying that the client is authorized to access the requested resources.</p> <p>It makes it easier for developers to enforce various forms of authorization policies including organizational role based access control (RBAC) policies when working with FHIR data.</p> <ul> <li>To enable authorization and access-control (ACL) policy enforcement between a   client application and a FHIR server, the Info Gateway is used along with an   Identity Provider (IDP) and Authorization server (AuthZ).</li> <li>The IDP can be a generic OpenID Connect (OIDC) compliant service or a special   purpose one.</li> <li>The IDP+AuthZ should provide a JSON Web Token (JWT) to the client. The client   uses this as a Bearer access-token (AT) when sending FHIR requests.</li> <li>A sample end-to-end implementation with Keycloak as the IDP+AuthZ service is   provided and has been tested with HAPI FHIR and Google Cloud Healthcare   FHIR-store as the FHIR server.</li> </ul> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<p>Key features of the Info Gateway include:</p> <ul> <li>A stand-alone service that can work with any FHIR compliant servers.</li> <li>A pluggable architecture for defining an access-checker to allow for   implementation configurability.</li> <li>Query filtering to block/allow specific queries.</li> <li>Post-processing of the results returned by the FHIR-server, for example to   remove sensitive information.</li> <li>A generic interface for implementing custom endpoints, e.g., a sync endpoint   to return updates for all patients assigned to a health-worker.</li> </ul>"},{"location":"#common-use-cases","title":"Common use cases","text":"<p>The Info Gateway is designed to solve for a generic problem, that is, access control for any client and any FHIR server.</p> <p>Common access-check use-cases include:</p> <ol> <li>For a mobile app used by community based front-line health workers possibly    with offline support</li> <li>Web based dashboard used by program admins</li> <li>For a personal health record app used by patients or caregivers</li> <li>To enable SMART-on-FHIR apps for patient or system level scopes</li> </ol> <p>FHIR Info Gateway is implemented as a \"FHIR facade\", i.e., it is a FHIR server itself which is implemented using the HAPI FHIR Plain Server library:</p> <p></p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#common-terminologies","title":"Common Terminologies","text":"<p>These are some common terminologies that are important when dealing with access control in general:</p> Term Description Authentication and Identity Provider (IDP) Who the user is. Establishing the identity can be done through a shared service (e.g., Google, GitHub) or a special one. Authorization (AuthZ) Given the identity, what can a user access? Has context specific pieces (e.g., scopes) Access-control How to make sure users access authorized resources only. This is the core focus of the info gateway. Client app An app which needs to access FHIR resources on behalf of a user. User The user that is using the app; this is the identity being \"authenticated\". Access Token A JWT that is provided as a Bearer token when accessing FHIR resources. OAuth2.0 A standard to grant access to an application on behalf of a user. SMART-on-FHIR Defines workflows that an application can use to securely request and access FHIR data. <p>The following picture helps to visualise the relationship of these concepts. A client app (e.g., a SMART-on-FHIR app) should first use a process to fetch an \"access token\" from the IDP+AuthZ service. For example, this process might be OAuth's Authorization Code Flow. This token is then provided on each request to the access-control gateway when accessing FHIR resources.</p> <p></p>"},{"location":"concepts/#info-gateway-modules","title":"Info Gateway Modules","text":"<p>The Info Gateway consists of a core, which is in the <code>server</code> module, and a set of access-checker plugins, which can be implemented by third parties and added to the proxy server. Two sample plugins are implemented in the <code>plugins</code> module.</p> <p>There is also a sample <code>exec</code> module which shows how all pieces can be woven together into a single Spring Boot app. It also has examples for implementing custom end-points.</p> <p>Notes:</p> <ul> <li>[1] Spring Boot is not a requirement for using FHIR Info Gateway; we just use   it to simplify the   MainApp.</li> <li>[2] The only Spring-related requirement is to do a   @ComponentScan   to find all access-checker plugins in the classpath.</li> </ul>"},{"location":"concepts/#configuration-parameters","title":"Configuration parameters","text":"<p>The configuration parameters are provided through environment variables:</p> <ul> <li><code>PROXY_TO</code>: The base url of the FHIR server e.g.:</li> </ul> <pre><code>export PROXY_TO=https://example.com/fhir\n</code></pre> <ul> <li><code>TOKEN_ISSUER</code>: The URL of the access token issuer, e.g.:</li> </ul> <pre><code>export TOKEN_ISSUER=http://localhost:9080/auth/realms/test\n</code></pre> <p>The above example is based on the default config of a test IDP+AuthZ   Keycloak server. To see how this server is   configured, check the   docker/keycloak   directory. If you want to use a SMART-on-FHIR (SoF) app use this realm instead   which is based on Keycloak's   SoF extension:</p> <pre><code>export TOKEN_ISSUER=http://localhost:9080/auth/realms/test-smart\n</code></pre> <ul> <li><code>ACCESS_CHECKER</code>: The access-checker to use. Each access-checker has a name   (see plugins for   details) and this variable should be set to the name of the plugin to use. For   example, to use one of the sample plugins use one of:</li> </ul> <pre><code>export ACCESS_CHECKER=list\nexport ACCESS_CHECKER=patient\n</code></pre> <p>For more information on how access-checkers work and building your own, see   section on access checkers.</p> <ul> <li><code>ALLOWED_QUERIES_FILE</code>: A list of URL requests that should bypass the access   checker and always be allowed.   <code>AllowedQueriesChecker</code>   compares the incoming request with a configured set of allowed-queries. The   intended use of this checker is to override all other access-checkers for   certain user-defined criteria. The user defines their criteria in a config   file and if the URL query matches an entry in the config file, access is   granted.   <code>AllowedQueriesConfig</code>   shows all the supported configurations. An example config file is   <code>hapi_page_url_allowed_queries.json</code>.   To use this file with <code>ALLOWED_QUERIES_FILE</code>:</li> </ul> <pre><code>export ALLOWED_QUERIES_FILE=\"resources/hapi_page_url_allowed_queries.json\"\n</code></pre> <ul> <li> <p><code>BACKEND_TYPE</code>: The type of backend, either <code>HAPI</code> or <code>GCP</code>. <code>HAPI</code> should be   used for most FHIR servers, while <code>GCP</code> should be used for GCP FHIR stores.</p> </li> <li> <p><code>AUDIT_EVENT_ACTIONS_CONFIG</code>: A flag to configure AuditEvent logging. Set to a   subset of <code>C</code>,<code>R</code>,<code>U</code>,<code>D</code> or <code>E</code> to enable and select the audit event actions   to be logged. This model is guided by the value set codes defined here -   https://hl7.org/fhir/R4/valueset-audit-event-action.html. When no value is set   or the value is an empty string, audit logging is disabled. If any other   character is set other than the predefined values, the server will fail to   start.</p> </li> </ul> <p>For more information on audit event logging, see   section on AuditEvent logging.</p>"},{"location":"concepts/#access-checkers","title":"Access Checkers","text":"<p>FHIR Info Gateway uses access checker plugins to define the logic it uses to make decisions for access requests. Most users should create an access checker plugin to implement the access control logic for a specific use case. You can learn about access checker plugins by looking at the sample access checker plugins.</p> <p>See tutorial on creating an access checker plugin. The core of FHIR Info Gateway, provides libraries that make it easier to create access-checkers. For example, PatientFinder can be used to limit access to a certain set of patients.</p>"},{"location":"concepts/#patient-access-checker-plugin","title":"Patient access checker plugin","text":"<p>The <code>PatientAccessChecker</code> plugin can be used if the client is a SMART-on-FHIR app that uses the standalone app launch flow. It expects a <code>patient_id</code> claim in the access-token and limits access to FHIR resources that belong to that patient. It supports SoF scopes (both v1 and v2).</p>"},{"location":"concepts/#explore-the-list-access-checker-plugin","title":"Explore the List access checker plugin","text":"<p>The <code>ListAccessChecker</code> plugin is a simple example of list-based access control. It works by assigning each user a FHIR <code>List</code> resource which contains a list of references of <code>Patient</code> resources that the user should have access to. When a client makes a request to FHIR Information Gateway, the <code>ListAccessChecker</code> grants access if all patients that are referenced in the query are on the user's patient access list.</p> <p>The plugin expects the patient <code>List</code> resource's ID to be included as the value to a claim named <code>patient_list</code> in the access token used to authorize requests to the FHIR Information Gateway server. For example, following the test Docker deployment you may get a decoded JWT like the following (note if you use the default settings you will get more claims that are not relevant to the access-checker logic; so they are removed in this example):</p> <pre><code>{\n  \"header\": {\n    \"alg\": \"RS256\",\n    \"typ\": \"JWT\",\n    \"kid\": \"MnXk25Vp_W6X_UMi4sA3_iEMwuumZkwhOuE8eMY8LFo\"\n  },\n  \"payload\": {\n    \"exp\": 1673990497,\n    \"iat\": 1673990197,\n    \"jti\": \"5bb2b1a0-e9c6-442f-abfd-a22f1798fd11\",\n    \"iss\": \"http://localhost:9080/auth/realms/test\",\n    \"aud\": \"account\",\n    \"sub\": \"76315cd1-9681-4a4e-b733-e6d811058e40\",\n    \"typ\": \"Bearer\",\n    \"azp\": \"my-fhir-client\",\n    \"session_state\": \"967e82a2-0188-4774-abbc-6bb4ce26536f\",\n    \"acr\": \"1\",\n    \"scope\": \"email profile\",\n    \"sid\": \"967e82a2-0188-4774-abbc-6bb4ce26536f\",\n    \"email_verified\": false,\n    \"patient_list\": \"patient-list-example\",\n    \"preferred_username\": \"testuser\",\n    \"group\": [\"fhirUser\"]\n  }\n}\n</code></pre> <p>Here <code>patient_list</code> equals <code>patient-list-example</code>, so if your FHIR server is at <code>http://localhost:8099/fhir/</code> then this user's patient access list resource is <code>http://localhost:8099/fhir/List/patient-list-example</code>.</p> <p>The decoded JWT is passed to the <code>AccessCheckerFactory</code> implementation's <code>create()</code> function. The <code>ListAccessChecker</code> implementation extracts the patient list ID from the JWT and saves it internally. Custom JWT claims in the access token can be a good way to pass additional information to your access checker beyond what your authentication server provides.</p> <p><code>ListAccessChecker</code>'s <code>checkAccess</code> function splits access logic according to the HTTP method. Simple yes/no access decisions like <code>processGet()</code> use the <code>NoOpAccessDecision</code> class which you may also use in your own implementations. Alternatively, you may have more complex decision needs, such as doing additional processing after the data access like <code>processPost()</code>. In this case, implement your own version of <code>AccessDecision</code>. The <code>ListAccessChecker</code> allows clients to create new <code>Patient</code> resources without restriction (always allow access), and then as a post-processing step adds the new Patient id to the client's patient access list. You can see this implemented in <code>AccessGrantedAndUpdateList</code>.</p>"},{"location":"concepts/#auditevent-logging","title":"AuditEvent logging","text":"<p>Given that every access to the FHIR server goes through the Gateway, it's the ideal place to track access for auditing. The Gateway simplifies enabling AuditEvent logging with these key features:</p>"},{"location":"concepts/#key-features","title":"Key Features","text":"<p>Comprehensive Audit Logging:</p> <ul> <li>Generates an AuditEvent for every   request processed by the Gateway, leveraging both request and response data.</li> <li>Adheres to the Basic Audit Logging Profiles (BALP) IG minimal audit patterns   (https://profiles.ihe.net/ITI/BALP/index.html).</li> <li>Stores AuditEvents on the same server as other data.</li> </ul> <p>Flexible Configuration:</p> <ul> <li>Allows configuration via environment variables (see   Configuration Parameters).</li> <li>Provides configurable <code>AuditEvent.agent[user].who</code> by overriding the default   <code>getUserWho</code> implementation   in the <code>AccessDecision</code> interface.</li> <li>Enables selection of logging actions based on HL7 FHIR R4   audit event actions value set codes.</li> <li>Audit logging can be disabled by omitting or setting any audit event action   codes to empty. Invalid values will result in an <code>IllegalStateException</code> on   the server.</li> </ul>"},{"location":"contribute/","title":"How to Contribute","text":"<p>We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.</p>"},{"location":"contribute/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>Contributions to this project must be accompanied by a Contributor License Agreement (CLA). You (or your employer) retain the copyright to your contribution; this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one.</p> <p>You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.</p>"},{"location":"contribute/#code-reviews","title":"Code reviews","text":"<p>All code changes require review. We use GitHub pull-requests for this purpose.</p> <ul> <li> <p>Consult GitHub Help   for more information on using pull requests.</p> </li> <li> <p>We use GitHub for issue tracking.</p> </li> </ul>"},{"location":"contribute/#community-guidelines","title":"Community Guidelines","text":"<p>This project follows Google's Open Source Community Guidelines.</p>"},{"location":"design/","title":"Secure FHIR Data Access Design Doc","text":"<p>In the context of healthcare data systems in resource constrained environments</p> <p>GitHub repository: https://github.com/google/fhir-gateway</p>"},{"location":"design/#summary","title":"Summary","text":""},{"location":"design/#the-problem","title":"The problem","text":"<p>We want to create an access-control gateway that is deployable in front of any generic FHIR server. The job of this gateway is to let authenticated users access only what they are authorized to. In most cases, this gateway acts as a reverse proxy. We want this proxy server to be scalable, independent of the FHIR store implementation, and deployable both on-premise and in any cloud. We also want the access rules to be customizable and fine-grained. For more context, please see the Introduction section.</p>"},{"location":"design/#summary-of-the-approach","title":"Summary of the approach","text":"<p>Here is a summary of proposals and decisions in this design document, for the first version (V1) of the FHIR gateway:</p> <p></p> <ul> <li>There are three main components responsible for access decisions: an Identity   Provider (IDP) which authenticates the user, an Authorization server (AuthZ)   that decides what a given user can access and an Access Gateway which enforces   those permissions. We are implementing the access gateway.</li> <li>The gateway has two main components: (i) a core \"server\" piece which   provides the servlets, interceptors, FHIR query processor, and other common   pieces to any access-control strategy and (ii) a customizable <code>AccessChecker</code>   \"plugin\".</li> <li>The authorization flow is based on the \"authorization code flow\" of OAuth 2.0.   This resembles SMART on FHIR spec   (SoF) but is not limited to it. In particular, some access-checker plugins may   rely on extra claims in the access token not defined in SoF. We did this   because the access controls captured in SoF did not seem sufficiently   expressive for a lot of use cases we have observed.</li> <li>We currently provide two example, default plugins: one that supports parts of   the SoF spec for patient context/scopes and one that is a simple list-based   access-checker.</li> <li>For access control rules, a plugin can choose to implement anything but there   is some functionality provided out-of-the-box by the server code that should   cover many cases:</li> <li>For FHIR queries scoped to a single (or group of) patients, there is a     library to extract referenced patient(s) from the query/resources, based on     the     Patient Compartment     definition. The expectation is that most access-control rules come down to     deciding whether the user has access to that patient data or not. The plugin     makes this decision.</li> <li>For searches beyond patient boundaries, define a set of templates to allow     or reject access based on the query string (i.e., the \"allow list\").</li> <li>We assume that the IDP+AuthZ together establish the user's identity and access   rules in a token of JWT type.   This \"access token\" should accompany requests to the gateway.</li> <li>The gateway will be implemented using HAPI FHIR libraries and is the main   focus of this design doc.</li> <li>The authorization server may implement authentication too or it may rely on a   separate authentication service that supports   OpenID Connect spec. Those details are beyond   this design doc.</li> <li>The server and plugin parts of the gateway will be released as libraries and   there would also be a sample \"main\" Spring Boot application which packages   everything in a single executable jar. This is easily deployable as a docker   container too.</li> </ul>"},{"location":"design/#introduction","title":"Introduction","text":"<p>The context of this document is implementation of access controls for FHIR resources. In particular, the focus is on web or mobile apps used by healthcare workers (HCW) who are often in low connectivity settings. For example a community health worker (CHW) collects data from patients and needs to sync that data with a central FHIR store. While our design is meant to be generic, we want to have great support for apps built on top of the Android FHIR SDK (\"the SDK\"). Data collected by all CHWs is centralized in a backend FHIR store (a.k.a., resource server, e.g., a GCP FHIR store or a HAPI FHIR server). The core issue is how to securely synchronize data between the FHIR store and the devices (the data-sync problem). The security question has three main components:</p> <ol> <li>[authentication] Who the user is? How do we establish the identity of     the end-user?</li> <li>[authorization] Given the identity of the user, what accesses are     granted to them? For example, a program administrator may have access to all     data while a CHW only has access to certain patient information in their own     catchment area.</li> <li>[access-control] How do we impose restrictions on FHIR store access     based on authorization credentials? For example, how do we make sure that an     authorized CHW can only access data for their own catchment area.</li> </ol> <p>The third component (i.e., the access-control) is the main focus of this design doc. The authentication and authorization parts are very much related to each other and we may refer to them collectively as authorization or \"auth\". For the auth problem, we only consider OAuth 2.0 based solutions and in particular we try to follow SMART on FHIR (SoF) spec for two main reasons:</p> <ol> <li>If we implement SoF support, it opens up the possibility of incorporating     many other SoF based applications with the FHIR-store. Consider a     practitioner that can easily use a 3rd party growth chart app on the data     they have already collected through their FHIR SDK based app.</li> <li>SoF is becoming the FHIR community's standard to build client apps on top of     FHIR-stores. So while in some places we have to deviate from that spec     because of its shortcomings, in many other places, we can simply follow the     recommendations of the spec to benefit from best practices.</li> </ol> <p>Note that the more difficult part of the problem that we are trying to solve is access-control which is not directly addressed by SoF, as clearly stated in section 3.0.1.1 of the current spec:</p> <p>\"Neither SMART on FHIR nor the FHIR Core specification provide a way to model the \"underlying\" permissions at play here; this is a lower-level responsibility in the access control stack. As such, clients can attempt to perform FHIR operations based on the scopes they are granted \u2014 but depending on the details of the underlying permission system (e.g., the permissions of the approving user and/or permissions assigned in a client-specific policy) these requests may be rejected, or results may be omitted from responses.\"</p>"},{"location":"design/#scenarios-and-constraints","title":"Scenarios and constraints","text":"<p>Some of the main scenarios that need to be supported are:</p> <ul> <li>[add-patient] A HCW registers a new patient, this needs to be sent to the   FHIR server. The HCW might be offline at the time of registration.</li> <li>[update-patient] Patient data is updated, e.g., a new Observation is added   by a HCW. Again the HCW might be offline at the time of data entry and many   updates might be communicated to the backend FHIR store at the time of server   synchronization.</li> <li>[fetch-my-patients] A HCW needs all updates to their patients, e.g.,   because they have switched their device or another HCW has updated the same   patient's data.</li> <li>[revoke-access] Revoke a previously issued (and still valid)   access/refresh token.</li> <li>[sof-apps] It should be easy to support other SoF-based apps. For example,   a patient wants to browse their own data through a 3rd party SoF-based app.   For now, we limit this scenario to apps that only need <code>patient/*</code> scopes.</li> </ul> <p>Constraints:</p> <ul> <li>[flexible-access-control] Enforce principle of least-privilege and   fine-grained access controls. For example, a HCW should have access only to   their own patients. A check could be implemented by looking at patients whose   <code>Patient.generalPractitioner</code></li> </ul> <p>references that HCW; or are in the region assigned to that HCW (using   Location, Organization, CareTeam, etc.). We may want to limit HCW's access to   some Observation types.</p> <ul> <li>[untrusted-app] The app cannot be assumed to be trusted; so   we should account for malicious access from the app; or abusing access tokens   issued for the app.</li> <li>[generalizable-design] The access gateway should be   independent of the specific FHIR server implementation, as much as possible.</li> </ul>"},{"location":"design/#the-high-level-design","title":"The high level design","text":"<p>Here we look at the big picture of the components involved and the main flow for accessing data. In subsequent sections we focus on the access gateway.</p>"},{"location":"design/#terminology-and-the-big-picture","title":"Terminology and the big picture","text":"<p>Before going into details, let's clarify some terminology:</p> <ul> <li>Client: The mobile or web app requesting access to resources. In the OAuth   2.0 sense, we mainly mean \"public clients\", i.e., there is no \"client secret\"   shared by the server.</li> <li>Access token: A string that can be used to access resources. While this   can be an \"opaque\" string, we use   JSON Web Token (JWT)   throughout this design.</li> <li>Authorization flow: Different ways for getting access tokens; our main     focus in this design is the     \"authorization code flow\"     but without any client secrets.</li> <li>Refresh token: A token for fetching a new access token when the old one   expires.</li> <li>Identity Provider (IDP): A [potentially shared] server to establish user   identity, e.g., Google, Twitter, GitHub, etc.</li> <li>Authorization server: A service that maps the user identity to some access   rules for FHIR store resources. In our design, this mapping is recorded in the   access token.</li> <li>OpenID Connect: An OAuth 2.0 based standard used by IDPs.</li> <li>ID token: A JWT issued by IDP proving the identity of the user</li> <li>Claims: Key-value pieces of information in JWTs</li> <li>Scopes: A set of predefined access rules to define what resources can be   accessed by an access token. These are represented as claims in the access   JWT.</li> </ul> <p>In our overall design, we treat IDP and authorization server as one whole, sometimes referred to as the Identity and Access Management (IAM) or simply \"auth server\". Obviously, IDP can be a separate (or even 3rd party) service (there are various architecture options briefly mentioned later).</p> <p>We also have an \"access gateway\" which is responsible for processing any access request for the FHIR server and is the main focus of this design doc.</p>"},{"location":"design/#authentication-and-authorization-flow","title":"Authentication and authorization flow","text":"<p>Before the user can access data, their identity should be established and based on that, the authorization scope be defined. Because the main focus of this doc is the access gateway, we keep this section brief. This is just to demonstrate the big picture and some best practices when deploying IDP and AuthZ servers.</p> <p>One of the recommended authorization flows and the one we consider here is the Authorization Code Flow. Since our main target is mobile (or single-page) apps that do not necessarily have a server side piece (a.k.a. \"public clients\"), we consider the flow with no client secrets. This flow resembles SMART on FHIR standalone app launch spec. There are at least three components we care about:</p> <ul> <li>the CHW app</li> <li>the auth service which is responsible for establishing the identity of the   user and authorizing access tokens.</li> <li>the FHIR resource server (e.g., GCP FHIR store or a HAPI FHIR server)</li> </ul> <p>Here is a simplified view of the authorization sequence (note it is recommended to use PKCE which is not shown in this diagram)<sup>1</sup>:</p> <p></p> <p>Here is a brief description of each step:</p> <ul> <li>A) The app makes a request to the auth server asking for an authorization   code (hence <code>response_type=code</code> parameter). This is a short lived code that   is sent back to the app if the user authentication is successful. This step   may involve some user interactions to establish the identity of the user and   pick a patient if the user has access to multiple patients.</li> <li>B) If the authentication/authorization is successful, the app receives the   authorization code AC. The optional parameter <code>state</code> is recommended to be   used in steps A and B for added security (to prevent replay attacks). In that   case, the app and auth server verify the <code>state</code>.</li> <li> <p>C) The app asks for an exchange of AC with an access token.</p> </li> <li> <p>D) The auth server verifies AC and on success returns an access token AT,   along with the approved scopes and other authorization claims needed for   access control.</p> </li> <li> <p>E) The app uses the access token AT to read patient related resources from the   FHIR store. At this point, the gateway imposes the access-control restrictions   implied by AT.</p> </li> </ul>"},{"location":"design/#other-architectures","title":"Other architectures","text":"<p>Before getting into details of how the access gateway works, let's look at other architectures where the main 3 components can be deployed. In all options, it is assumed that the IDP is an OpenID Connect compliant service.</p> <p>Separate IDP</p> <p>If desired, the IDP can be separated and a third-party shared service be used. In this case, IDP provides an ID token to AuthZ which in turn maps the user identity to some access rules to FHIR resources. Popular IAM servers like Keycloak, support separate/3rd party IDPs.</p> <p></p> <p>Integrated AuthZ+Gateway</p> <p>It is also possible to only have the IDP as an external service. In this case, the access gateway and AuthZ are the same service. All that this service needs is an ID token from the IDP. Based on the user identity (e.g., their email address) the service decides what resources they have access to. This approach simplifies the deployment architecture significantly, however we note that the elimination of the access token might be incompatible with some use-cases like SoF apps.</p> <p></p>"},{"location":"design/#access-gateway","title":"Access gateway","text":"<p>Assume that we have established the identity of the end-user and authorized them for certain access scopes. Now, we should make sure that authorized requests do not access information beyond what the user is granted to. This is done by the Access Gateway which sits between the app and FHIR store. This is where all ACLs are applied; here are some examples we want to eventually support:</p> <ul> <li>For a practitioner, only access to their own patients are granted. The   definition of one's patients could be configured through implementation of the   access-checker plugin. For example:</li> <li>Patients in a specific FHIR List resource.</li> <li>Any patient in CHW's catchment area.</li> <li>Any patient whose <code>generalPractitioner</code> contains that CHW.</li> <li>Observations of sensitive types can only be accessed by certain users.</li> <li>For a patient user, only access to their own data is granted and SoF scopes   rules are imposed too.</li> </ul> <p>Note we are not assuming any access-control support from the FHIR store itself because of the generalizable-design constraint.</p> <p>It is a good idea to look at a few FHIR query examples and their access control challenges before diving into solutions. Some examples are provided in the query examples appendix. We propose four main approaches for access control:</p> <ul> <li>Patient context enforcement: Limit queries to data for a single patient</li> <li>Query templates: Limit the non-patient queries to a small number of   templates.</li> <li>Query rewrite: Send a modified query to the FHIR store which guarantees   access-control requirements.</li> <li>Post processing: Post process FHIR store results and redact sensitive   information.</li> </ul> <p>By providing developers the ability to customize each of these, we believe that this gateway can support many different models of access control, which often varies by context.</p> <p>Each of these approaches are described in the following sections. In each case, we briefly describe what is supported in the first release of the access gateway. The \"first release\" is when we open-sourced the project in June 2022 in this GitHub repository. Let's first look at the architecture of the gateway. There are two main components:</p> <p>Server: The core of the access gateway is the \"server\" which provides a servlet that processes FHIR queries and an authorization interceptor that inspects those. The interceptor decodes and validates the JWT access-token and makes a call to an AccessChecker plugin to decide whether access should be granted or not. The server also provides common FHIR query/resource processing, e.g., PatientFinder for finding patient context. These libraries are meant to be used in the plugin implementations.</p> <p>AccessChecker plugin: Each access gateway needs at least one AccessChecker plugin. Gateway implementers can provide their customized access-check logic in this plugin. The server code's initialization finds plugins by looking for AccessCheckerFactory implementations that are @Named. The specified name is used to select that plugin at runtime. Example implementations are ListAccessChecker and PatientAccessChecker. AccessChecker plugins can send RPCs to other backends if they need to collect extra information. In our examples, the plugins consult with the same FHIR store that resources are pulled from, but you could imagine consulting more hardened storage solutions dedicated to maintaining access control rules.</p> <p>With this general architecture in mind, now let's look at different access-control methods.</p>"},{"location":"design/#patient-context-enforcement","title":"Patient context enforcement","text":"<p>Most of the use-cases we have can be handled if we limit a query to a single patient's resource. For example an Observation search query with a <code>patient=PID</code> query parameter, guarantees that the result is for the given patient.</p> <p>The mapping from resources to patients is done through the patient compartment definition. Note that we can still access many resources in one query; in particular through Patient/ID/$everything queries, we can fetch all updates for a single patient.</p> <p>This approach helps support both the flexible-access-control and untrusted-app items from the constraints section. Note to use this approach for access-control, the patient context should be inferred from the FHIR query. The server provides a library for doing this.</p>"},{"location":"design/#query-templates-allowedblocked-list","title":"Query templates allowed/blocked list","text":"<p>We may need to expose FHIR data that cannot be represented in a patient compartment query. For example, fetching a particular non-patient resource that is needed on the client side. For these we propose using a small set of allowed query templates. We can also have a list of blocked templates that may even apply to patient queries. For example, one implementation may decide to disable reverse chaining by blocking queries with <code>_has</code> query parameters (note this is disabled by default in the first release for security reasons described in the appendix.</p> <p>A notable item needed in the allowed-list for a HAPI FHIR server is the search page pattern. These queries with a <code>_getpages</code> query parameter identify cached search results of a previous query. Just from these queries, we cannot decide what the patient context is, so we should let those queries go through (there is a security risk here but since <code>_getpages</code> param values are ephemeral UUIDs, this is probably ok). Here is a sample config for this. We note that we want our core \"server\" to be stateless (for easy scalability); therefore cannot store next/prev URLs from previous query results.</p>"},{"location":"design/#query-rewrite","title":"Query rewrite","text":"<p>We can add extra query parameters to a FHIR request to make sure it stays within the limits of the granted access. For example, we can add constraints to an Observation search query to exclude sensitive Observations. Or we can add security label constraints in a search query. Note this feature is not implemented in the first release.</p>"},{"location":"design/#post-processing-and-security-labels","title":"Post-processing and security labels","text":"<p>Another access-control option is to inspect the returned resources before sending them back to the client. So the access gateway fetches the resources and then checks if the user has access to those. For example, when fetching a resource by ID (e.g., <code>/Observation/obs-id</code>) it is impossible to determine the patient context from the query string. So we can fetch the resource and then check if the user is allowed to access the patient(s) referenced in that resource. Or we can apply security label constraints. Note these imply some non-trivial overhead work for processing FHIR resources.</p> <p>Note that even this kind of fine-grained control, does not address all of the sensitive-data scenarios because of reverse chaining (if we do not limit the structure of FHIR queries that the gateway accepts). So we still need some restrictions on the permitted queries as mentioned above.</p> <p>Among gateway interfaces, there is AccessDecision which is returned from a checkAccess. This interface has a postProcess method which can be used for post-processing of resources returned from the FHIR server.</p>"},{"location":"design/#the-sync-flow","title":"The sync. flow","text":"<p>Here is a demonstration of how a sample HCW app can fetch data from a FHIR server while access-control policies apply.</p> <ul> <li>The client app redirects the HCW to the \"auth server\" (AuthZ+IDP) to   authenticate the user and annotate their access tokens with required   authorization claims.</li> <li>The client fetches the access token from AuthZ.</li> <li>The client sends the access token along with a FHIR query to the access   gateway.</li> <li>The gateway verifies the token and checks that every resource accessed belongs   to a patient the client is authorized to access and/or is compatible with the   authorized templates.</li> <li>The gateway relays the query to the FHIR store.</li> <li>Upon the store's response, the gateway makes any post-processing required and   returns the outcome to the client.</li> </ul> <p>Through this process, add-patient, update-patient, and fetch-my-patients scenarios can be handled. To support sof-apps (assuming that the auth server supports SoF scopes), we should implement access control rules based on SoF scopes (which is provided in a plugin). One example of an auth server with SoF support is Keycloak with SoF extension.</p>"},{"location":"design/#relevant-documents-and-background-information","title":"Relevant documents and background information","text":"<ul> <li>FHIR Security page.</li> <li>A collection of resources about SMART on   FHIR from SMART Health.</li> <li>An   extension to Keycloak   to support SMART on FHIR claims.</li> <li>New version of SMART scopes and context document.</li> </ul>"},{"location":"design/#appendix","title":"Appendix","text":""},{"location":"design/#fhir-query-examples-and-access-control-challenges","title":"FHIR query examples and access control challenges","text":"<p>To better understand the complexity we are dealing with, let's look at three FHIR search queries and options for dealing with them. Two fundamental access constraints are that a HCW should not have access to:</p> <ol> <li>resources of patients not assigned to him/her</li> <li>sensitive data (defined based on HCW's role)</li> </ol> <p>The three queries are:</p> <ul> <li>fetching all Patients</li> <li>accessing sensitive Observations</li> <li>reverse chaining searches</li> </ul> <p>For each query, we look at possible ways we can implement access control rules.</p>"},{"location":"design/#fetching-all-patients","title":"Fetching all patients","text":"<p>Consider fetching all patients by a HCW app. What should the access gateway do if the query is</p> <p>\"<code>GET [base]/Patient</code>\"? Some options are:</p> <ul> <li>[permitted-templates] We can reject the query because it is not in the   list of permitted query templates; the relevant permitted template could have   a parameter that limits the patient, practitioner, location, etc. (see below).</li> <li>[query-rewrite] We can add a constraint to impose a location based   restriction, e.g., if the current CHW user has access to patients in city   \"CityHCW\":</li> </ul> <pre><code>GET [base]/Patient?address-city=CityCHW\n</code></pre> <ul> <li>[query-rewrite] We can add a practitioner constraint e,g.,:</li> </ul> <pre><code>GET [base]/Patient?general-practitioner=Practitioner/HCW-ID\n</code></pre> <ul> <li>[post-processing] We can retrieve all results from the FHIR store, then   post-process them and drop everything that does not belong to this HCW.</li> </ul>"},{"location":"design/#sensitive-data","title":"Sensitive data","text":"<p>Now let's consider access to sensitive data. Assume that the HIV status is a sensitive Observation that we don't want to expose to some HCWs. What should we do for the following query that fetches all Observations of a patient: \"<code>GET /Observation?subject=Patient/PID</code>\"?</p> <ul> <li>[query-rewrite] Add the constraint to drop viral load for HIV:</li> </ul> <p>\"<code>GET /Observation?subject=Patient/PID&amp;code:not=http://loinc.org|59419-2</code>\"</p> <ul> <li>[permitted-templates] Similar to the above \"all patients\" example.</li> <li>[post-processing] From the returned results, remove all Observation   resources that have HIV viral load code.</li> </ul> <p>Note for the first two options we should probably use a ValueSet if there are a lot of Observation codes that we want to protect.</p>"},{"location":"design/#reverse-chaining","title":"Reverse chaining","text":"<p>Finally, to see how this problem can get complicated quickly, consider this query:</p> <p>\"<code>GET [base]/Patient?_id=PID&amp;_has:Observation:patient:code-value-quantity=http://loinc.org|59419-2$gt1000||</code>\".</p> <p>This query is a reverse chaining query which returns the queried Patients if they had a high HIV viral load. Post-processing cannot help here in hiding the HIV status information because the returned resources are Patients, not Observations. Also query-rewriting is difficult as we have to understand the full semantics of the query; so we cannot just add a simple query parameter like previous examples (this is the reason we have disabled \"chaining\" in the first release).</p> <p>In the main text, we refer to these examples by \"all-patients\", \"sensitive-data\", and \"reverse-chaining\" queries.</p>"},{"location":"design/#notes","title":"Notes","text":"<p>The simplified Implicit flow could work for our use-case too but that has important security shortcomings. For example, it exposes access_token in URLs which can leak through browser history. Another more important shortcoming is that we cannot implement PKCE in the Implicit flow as the access_token is directly returned in the first request.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Quick Start Guide</p> <p>The easiest way to get started is to follow the \"Run the Info Gateway in Docker\" guide.</p>"},{"location":"getting_started/#building-from-source","title":"Building from source","text":"<p>To build all modules, from the root run (if you are a developer, do not use <code>spotless.apply.skip=true</code>):</p> <pre><code>mvn package -Dspotless.apply.skip=true\n</code></pre> <p>The <code>server</code> and <code>plugins</code> modules can be run together through this executable jar (<code>--server.port</code> is just one of the many default Spring Boot flags):</p> <pre><code>java -jar exec/target/exec-0.1.0.jar --server.port=8081\n</code></pre> <p>Note that extra access-checker plugins can be added through the <code>loader.path</code> property (although it is probably easier to build them into your server):</p> <pre><code>java -Dloader.path=\"PATH-TO-ADDITIONAL-PLUGINGS/custom-plugins.jar\" \\\n  -jar exec/target/exec-0.1.0.jar --server.port=8081\n</code></pre> <p>The plugin library can be swapped with any third party access-checker as described in the plugins directory. Learn more about AccessCheckers.</p>"},{"location":"getting_started/#gateway-to-server-access","title":"Gateway to server access","text":"<p>The proxy must be able to send FHIR queries to the FHIR server. The FHIR server must be configured to accept connections from the proxy while rejecting most other requests.</p> <p>If you use a GCP FHIR store you have the following options:</p> <ul> <li> <p>If you have access to the FHIR store, you can use your own credentials by   doing   application-default login.   This is useful when testing the proxy on your local machine, and you have   access to the FHIR server through your credentials.</p> </li> <li> <p>Use a service account with required access (e.g., \"Healthcare FHIR Resource   Reader\", \"Healthcare Dataset Viewer\", \"Healthcare FHIR Store Viewer\"). You can   then run the proxy in the same GCP project on a VM with this service account.</p> </li> <li> <p>[not-recommended] You can create and download a key file for the above service   account, then use it with:   <pre><code>export GOOGLE_APPLICATION_CREDENTIALS=\"PATH_TO_THE_JSON_KEY_FILE\"\n</code></pre></p> </li> </ul>"},{"location":"getting_started/#running-the-gateway","title":"Running the gateway","text":"<p>Configuration Parameters</p> <p>Take a moment to review the configuration parameters.</p> <p>Once you have set all the above, you can run the proxy server. The sample <code>exec</code> module uses Apache Tomcat through Spring Boot and the usual configuration parameters apply, e.g., to run on port 8081:</p> <pre><code>java -jar exec/target/exec-0.1.0.jar --server.port=8081\n</code></pre> <p>Android Emulator</p> <p>If the <code>TOKEN_ISSUER</code> is on the <code>localhost</code> and you are accessing the gateway from an Android emulator (which runs on a separate network), you may need to bypass proxy's token issuer check by setting <code>RUN_MODE=DEV</code> environment variable.</p>"},{"location":"getting_started/#using-the-info-gateway","title":"Using the Info Gateway","text":"<p>In this section we assume that a Keycloak instance is set up using the sample docker setup provided here. If you have a different IDP+AuthZ setup, you need to adjust the parameters below accordingly.</p> <p>Once the gateway is running, we first need to fetch an access token from the <code>TOKEN_ISSUER</code>; you need the test server's <code>username</code> and <code>password</code> plus the <code>client_id</code>:</p> <pre><code>$ curl -X POST -d 'client_id=CLIENT_ID' -d 'username=testuser' \\\n  -d 'password=testpass' -d 'grant_type=password' \\\n\"http://localhost:9080/auth/realms/test/protocol/openid-connect/token\"\n</code></pre> <p>We need the <code>access_token</code> of the returned JSON to be able to convince the gateway to authorize our FHIR requests (there is also a <code>refresh_token</code> in the above response). Assuming this is stored in the <code>ACCESS_TOKEN</code> environment variable, we can access the FHIR store:</p> <pre><code>$ curl -X GET -H \"Authorization: Bearer ${ACCESS_TOKEN}\" \\\n-H \"Content-Type: application/json; charset=utf-8\" \\\n'http://localhost:8081/Patient/f16b5191-af47-4c5a-b9ca-71e0a4365824'\n</code></pre> <pre><code>$ curl -X PUT -H \"Authorization: Bearer ${ACCESS_TOKEN}\" \\\n-H \"Content-Type: application/json; charset=utf-8\" \\\n'http://localhost:8081/Patient/f16b5191-af47-4c5a-b9ca-71e0a4365824' \\\n-d @Patient_f16b5191-af47-4c5a-b9ca-71e0a4365824_modified.json\n</code></pre> <p>Of course, whether a query is accepted or denied, depends on the access-checker used and the <code>ACCESS_TOKEN</code> claims.</p> <p>For example:</p> <ul> <li>For <code>ACCESS_CHECKER=list</code> there should be a <code>patient_list</code> claim which is the   ID of a <code>List</code> FHIR resource with all the patients that this user has access   to.</li> <li>For <code>ACCESS_CHECKER=patient</code>, there should be a <code>patient_id</code> claim with a   valid Patient resource ID.</li> </ul>"},{"location":"release_process/","title":"Semantic versioning","text":"<p>FHIR Info Gateway artifacts are released on Maven. A docker image is also published on GCP Artifact Registry.</p> <p>Versioning across all Open Health Stack components is based on the major.minor.patch scheme and respects Semantic Versioning.</p> <p>Respecting Semantic Versioning is important for multiple reasons:</p> <ul> <li>It guarantees simple minor version upgrades, as long as you only use the   public APIs.</li> <li>A new major version is an opportunity to thoroughly document breaking changes.</li> <li>A new major/minor version is an opportunity to communicate new features   through a blog post.</li> </ul>"},{"location":"release_process/#major-versions","title":"Major versions","text":"<p>The major version number is incremented on every breaking change.</p> <p>Whenever a new major version is released, we publish:</p> <ul> <li>a blog post with feature highlights, major bug fixes, breaking changes, and   upgrade instructions.</li> <li>an exhaustive changelog entry via the release notes</li> </ul>"},{"location":"release_process/#minor-versions","title":"Minor versions","text":"<p>The minor version number is incremented on every significant retro-compatible change.</p> <p>Whenever a new minor version is released, we publish:</p> <ul> <li>an exhaustive changelog entry via the release notes.</li> </ul>"},{"location":"release_process/#patch-versions","title":"Patch versions","text":"<p>The patch version number is incremented on bugfixes releases.</p> <p>Whenever a new patch version is released, we publish:</p> <ul> <li>an exhaustive changelog entry.</li> </ul>"},{"location":"support/","title":"Support","text":"<p>On this page we've listed some ways you can get technical support along with Open Health Stack communities and forums that you can be a part of.</p> <p>Before participating please read our code of conduct that we expect all community members to adhere too.</p>"},{"location":"support/#developer-calls","title":"Developer calls","text":"<p>There are weekly Open Health Stack developer calls that you are welcome to join.</p> <ul> <li>Calls are on Thursdays and alternate between Android FHIR SDK and OHS   server side components (FHIR Data Pipes and Info Gateway).</li> <li>See the schedule below for more details.</li> <li>To be added to the calls, please email: <code>hello-ohs[at]google.com</code>.</li> </ul> <p>Developer call schedule</p> OHS Developers Call GMT East Africa India Android FHIR SDK 10:00 UK 12:00 Nairobi 14:30 Delhi Analytics and Info Gateway 13:00 UK 15:00 Nairobi 17:30 Delhi"},{"location":"support/#discussion-forums","title":"Discussion forums","text":"<p>We are in the process of setting up a dedicated discussion forum for Open Health Stack. In the meantime, you can reach out to <code>hello-ohs[at]google.com</code>.</p>"},{"location":"support/#stack-overflow","title":"Stack Overflow","text":"<p>Stack Overflow is a popular forum to ask code-level questions or if you're stuck with a specific error. It would be nice to tag your question with <code>open-health-stack</code>!</p>"},{"location":"support/#bugs-or-feature-requests","title":"Bugs or Feature requests","text":"<p>Before submitting a bug or filing a feature reqeust, please review the open issues on our github repository.</p> <p>If your issue is there, please add a comment. Otherwise, create a new issue to file a bug or submit a new feature request.</p> <p>Please review the contributing section.</p>"},{"location":"tutorial_docker/","title":"Run the Info Gateway in Docker","text":"<p>In this guide, you will learn how to run FHIR Info Gateway in a Docker image, and see it work in concert with a sample Keycloak and HAPI FHIR server running on your local machine. We assume that Docker and Docker Compose are installed. The sample commands are shown on a Linux/shell environment and may need to be adjusted for your environment.</p> <p>Important</p> <p>The setup used in this guide should not be used in a production environment. It is designed to get things up and running quickly for demonstration or testing purposes only. The FHIR Information Gateway Docker image might be used in a production environment if deployed appropriately, however the example access-checker plugins may not satisfy real-world use cases.</p>"},{"location":"tutorial_docker/#start-the-docker-images","title":"Start the Docker images","text":"<ol> <li>Clone the    FHIR Info Gateway repo from GitHub.</li> <li>Open a terminal window and <code>cd</code> to the directory where you cloned the repo.</li> <li>Bring up the sample Keycloak service using <code>docker compose</code>.</li> </ol> <pre><code>docker compose -f docker/keycloak/config-compose.yaml up\n</code></pre> <p>This runs an instance of Keycloak with    SoF extension,    preloaded with a test configuration. It is accessible at    <code>http://localhost:9080</code>.</p> <ol> <li>Run the sample HAPI FHIR server Docker image.</li> </ol> <pre><code>docker run -p 8099:8080 us-docker.pkg.dev/fhir-proxy-build/stable/hapi-synthea:latest\n</code></pre> <p>The server is preloaded with synthetic patient data and a FHIR    <code>List/patient-list-example</code> resource.</p> <ol> <li>Run the FHIR Information Gateway Docker image with the <code>list</code> access checker.    <pre><code>docker run \\\n  -e TOKEN_ISSUER=http://localhost:9080/auth/realms/test \\\n  -e PROXY_TO=http://localhost:8099/fhir \\\n  -e BACKEND_TYPE=HAPI \\\n  -e RUN_MODE=PROD \\\n  -e ACCESS_CHECKER=list \\\n  --network=host \\\n  us-docker.pkg.dev/fhir-proxy-build/stable/fhir-gateway:latest\n</code></pre></li> </ol> <p>Several environment variables are used to configure FHIR Information Gateway:</p> <ul> <li><code>TOKEN_ISSUER</code>: The URL of the token issuer. For Keycloak this is typically   <code>http://{keycloak-host}:{keycloak-port}/auth/realms/{realm-name}</code>.</li> <li><code>PROXY_TO</code>: The Service Base URL of   the FHIR server that FHIR Access Proxy communicates with.</li> <li><code>BACKEND_TYPE</code>: One of <code>HAPI</code> for a HAPI FHIR Server or <code>GCP</code> for a Cloud   Healthcare FHIR-store.</li> <li><code>RUN_MODE</code>: One of <code>PROD</code> or <code>DEV</code>. DEV removes validation of the issuer URL,   which is useful when using the docker image with an Android emulator as the   emulator runs on its own virtual network and sees a different address than the   host.</li> <li><code>ACCESS_CHECKER</code>: The access-checker plugin to use. The Docker image includes   the   <code>list</code>   and   <code>patient</code>   example access-checkers.</li> <li><code>AUDIT_EVENT_ACTIONS_CONFIG</code>: A flag to configure AuditEvent logging. Set to   either <code>C</code>,<code>R</code>,<code>U</code>,<code>D</code> or <code>E</code> to enable and select the audit event actions to   be logged. This model is guided by the value set codes defined here -   https://hl7.org/fhir/R4/valueset-audit-event-action.html. Absence of any   (valid) means audit logging is disabled.</li> </ul> <p>GCP Note</p> <p>If the FHIR server is GCP FHIR-store and the gateway is not run on a VM with proper service account (e.g., running on a localhost), you need to pass GCP credentials to it, for example by mapping the <code>.config/gcloud</code> volume (i.e., add <code>-v ~/.config/gcloud:/root/.config/gcloud</code> to the above command).</p>"},{"location":"tutorial_docker/#examine-the-sample-keycloak-configuration","title":"Examine the sample Keycloak configuration","text":"<p>In this section you will review the Keycloak settings relevant to the FHIR Information Gateway with the sample <code>list</code> access checker plugin.</p> <ol> <li>Open a web browser and navigate to <code>http://localhost:9080/auth/admin/</code>.</li> <li>Login using user <code>admin</code> and password <code>adminpass</code>.</li> <li>Select the <code>test</code> realm.</li> <li>From the left menu, find the Manage section and click Users. Click     View all users, then click the ID of the only result to view the     user <code>Testuser</code>.</li> <li>Select the Attributes tab. Note the attribute <code>patient_list</code> with value     <code>patient-list-example</code>. The client <code>my-fhir-client</code> has a corresponding     User Attribute mapper     to add this as a claim to the access token JWT, which you can see under     Clients &gt; my-fhir-client &gt; Mappers &gt; list-mapper.</li> <li> <p><code>patient-list-example</code> is the ID of a FHIR List resource which lists all the     Patient resources the user can access. Open     <code>http://localhost:8099/fhir/List/patient-list-example</code> to see the list     referencing two Patients:</p> <pre><code>...\n\"entry\": [ {\n  \"item\": {\n    \"reference\": \"Patient/75270\"\n  }\n}, {\n  \"item\": {\n    \"reference\": \"Patient/3810\"\n  }\n} ]\n...\n</code></pre> </li> </ol>"},{"location":"tutorial_docker/#get-a-fhir-resource-using-fhir-information-gateway","title":"Get a FHIR resource using FHIR Information Gateway","text":"<ol> <li> <p>Get an access token for the test user. This command uses     jq to parse the access token from the JSON     response.</p> <pre><code>ACCESS_TOKEN=\"$( \\\n  curl -X POST \\\n      -d 'client_id=my-fhir-client' \\\n      -d 'username=testuser' \\\n      -d 'password=testpass' \\\n      -d 'grant_type=password' \\\n      \"http://localhost:9080/auth/realms/test/protocol/openid-connect/token\" \\\n    | jq .access_token \\\n    | tr -d '\"' \\\n)\"\n</code></pre> <p>You will need to rerun this command when the access token expires after 5 minutes. In a real application, implement your Identity Provider's authentication flow, including refresh tokens.</p> </li> <li> <p>Send a request to FHIR Information Gateway using the access token.</p> <pre><code>curl -X GET -H \"Authorization: Bearer ${ACCESS_TOKEN}\" \\\n-H \"Content-Type: application/json; charset=utf-8\" \\\n'http://localhost:8080/fhir/Patient/75270'\n</code></pre> <p>You should get a response containing the Patient resource.</p> </li> <li> <p>Send a second request for a patient the user does not have access to.</p> <pre><code>curl -X GET -H \"Authorization: Bearer ${ACCESS_TOKEN}\" \\\n-H \"Content-Type: application/json; charset=utf-8\" \\\n'http://localhost:8080/fhir/Patient/3'\n</code></pre> <p>You should get a response of <code>User is not authorized to GET http://localhost:8080/fhir/Patient/3</code>.</p> </li> </ol>"},{"location":"tutorial_first_access_checker/","title":"Create an access checker plugin","text":"<p>In this guide you will create your own access checker plugin.</p>"},{"location":"tutorial_first_access_checker/#implement-the-accesscheckerfactory-interface","title":"Implement the <code>AccessCheckerFactory</code> interface","text":"<p>To create your own access checker plugin, create an implementation of the <code>AccessCheckerFactory</code> interface annotated with a <code>@Named(value = \"name\")</code> annotation defining the name of the plugin.</p> <p>The most important parts are to implement a custom <code>AccessChecker</code> to be returned by the factory and its <code>checkAccess</code> function which specifies if access is granted or not by returning an <code>AccessDecision</code>.</p>"},{"location":"tutorial_first_access_checker/#create-a-new-class","title":"Create a new class","text":"<p>The simplest way to create your own access checker is to make a new class file in the <code>plugins/src/main/java/com/google/fhir/gateway/plugin</code> directory, next to the existing sample plugins. The following code can be used as a starting template for a minimal access checker:</p> <pre><code>package com.google.fhir.gateway.plugin;\n\nimport ca.uhn.fhir.context.FhirContext;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.google.fhir.gateway.FhirUtil;\nimport com.google.fhir.gateway.HttpFhirClient;\nimport com.google.fhir.gateway.JwtUtil;\nimport com.google.fhir.gateway.interfaces.AccessChecker;\nimport com.google.fhir.gateway.interfaces.AccessCheckerFactory;\nimport com.google.fhir.gateway.interfaces.AccessDecision;\nimport com.google.fhir.gateway.interfaces.NoOpAccessDecision;\nimport com.google.fhir.gateway.interfaces.PatientFinder;\nimport com.google.fhir.gateway.interfaces.RequestDetailsReader;\nimport javax.inject.Named;\n\npublic class MyAccessChecker implements AccessChecker {\n\n  private final FhirContext fhirContext;\n  private final HttpFhirClient httpFhirClient;\n  private final String claim;\n  private final PatientFinder patientFinder;\n\n  // We're not using any of the parameters here, but real access checkers\n  // would likely use some/all.\n  private MyAccessChecker(\n      HttpFhirClient httpFhirClient,\n      String claim,\n      FhirContext fhirContext,\n      PatientFinder patientFinder) {\n    this.fhirContext = fhirContext;\n    this.claim = claim;\n    this.httpFhirClient = httpFhirClient;\n    this.patientFinder = patientFinder;\n  }\n\n  @Override\n  public AccessDecision checkAccess(RequestDetailsReader requestDetails) {\n    // Implement your access logic here.\n    return NoOpAccessDecision.accessGranted();\n  }\n\n  // The factory must be thread-safe but the AccessChecker instances it returns\n  // do not need to be thread-safe.\n  @Named(value = \"sample\")\n  public static class Factory implements AccessCheckerFactory {\n\n    static final String CLAIM = \"sub\";\n\n    private String getClaim(DecodedJWT jwt) {\n      return FhirUtil.checkIdOrFail(JwtUtil.getClaimOrDie(jwt, CLAIM));\n    }\n\n    @Override\n    public AccessChecker create(\n        DecodedJWT jwt,\n        HttpFhirClient httpFhirClient,\n        FhirContext fhirContext,\n        PatientFinder patientFinder) {\n      String claim = getClaim(jwt);\n      return new MyAccessChecker(httpFhirClient, claim, fhirContext, patientFinder);\n    }\n  }\n}\n</code></pre>"},{"location":"tutorial_first_access_checker/#rebuild-to-include-the-plugin","title":"Rebuild to include the plugin","text":"<p>Once you're done implementing your access checker plugin, rebuild using <code>mvn package</code> from the root of the project to include the plugin, set the access-checker using e.g. <code>export ACCESS_CHECKER=sample</code></p>"},{"location":"tutorial_first_access_checker/#run-the-gateway","title":"Run the gateway","text":"<p>Run the gateway using e.g. <code>java -jar exec/target/exec-0.1.0.jar --server.port=8080</code>.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Explore the developer resources to learn how to get started with the Info Gateway</p>"}]}